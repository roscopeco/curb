# Generated by ffi_gen, but since changed by hand, so knock yourself out...
#
# TODO This code is an unholy mess, and needs to be sorted out.
# Right now it's a mix of generated code, borrowed bits from other 
# projects, and hand-rolled stuff thrown together in whatever order
# will compile...
#   

require 'ffi'

module Curl
  class PostField
    class << self
      def file(*args)
        PostField.new
      end
      
      def content(*args)
        PostField.new
      end
    end
    
    attr_reader(:name, :remote_file, :local_file, :content_type)
  end  

  module Libc
      extend FFI::Library
      ffi_lib 'c'

      unless FFI::Platform.windows?
        attach_function :getdtablesize, [], :int
      end
  end  
  
  module Core
    extend FFI::Library
    ffi_lib "libcurl"

    class << self
      def attach_function(name, *_)
        begin; super; rescue FFI::NotFoundError => e
          (class << self; self; end).class_eval { define_method(name) { |*_| raise e } }
        end
      end      
    
      # Helper to convert enum symbols to numbers
      def sym2num(sym)
        enum_value(sym)
      end    
    end    

    # Some types we use here and there
    class IntPtr < FFI::Struct
      layout  :value, :int
    end
        
    # THIS CODE COMES FROM https://github.com/arthurschreiber/curl-ffi/blob/master/lib/curl/curl.rb
    if FFI::Platform.windows?
      typedef :uint, :curl_socket_t
      SOCKET_BAD = 4294967295
    else
      typedef :int, :curl_socket_t
      SOCKET_BAD = -1
    end
    
    HTTPPOST_FILENAME = (1<<0)
    
    HTTPPOST_READFILE = (1<<1)
    
    HTTPPOST_PTRNAME = (1<<2)
    
    HTTPPOST_PTRCONTENTS = (1<<3)
    
    HTTPPOST_BUFFER = (1<<4)
    
    HTTPPOST_PTRBUFFER = (1<<5)
    
    HTTPPOST_CALLBACK = (1<<6)
    
    HTTPPOST_LARGE = (1<<7)
    
    MAX_READ_SIZE = 524288
    
    MAX_WRITE_SIZE = 16384
    
    WRITEFUNC_PAUSE = 0x10000001
    
    FINFOFLAG_KNOWN_FILENAME = (1<<0)
    
    FINFOFLAG_KNOWN_FILETYPE = (1<<1)
    
    FINFOFLAG_KNOWN_TIME = (1<<2)
    
    FINFOFLAG_KNOWN_PERM = (1<<3)
    
    FINFOFLAG_KNOWN_UID = (1<<4)
    
    FINFOFLAG_KNOWN_GID = (1<<5)
    
    FINFOFLAG_KNOWN_SIZE = (1<<6)
    
    FINFOFLAG_KNOWN_HLINKCOUNT = (1<<7)
    
    CHUNK_BGN_FUNC_OK = 0
    
    CHUNK_BGN_FUNC_FAIL = 1
    
    CHUNK_BGN_FUNC_SKIP = 2
    
    CHUNK_END_FUNC_OK = 0
    
    CHUNK_END_FUNC_FAIL = 1
    
    FNMATCHFUNC_MATCH = 0
    
    FNMATCHFUNC_NOMATCH = 1
    
    FNMATCHFUNC_FAIL = 2
    
    SEEKFUNC_OK = 0
    
    SEEKFUNC_FAIL = 1
    
    SEEKFUNC_CANTSEEK = 2
    
    READFUNC_ABORT = 0x10000000
    
    READFUNC_PAUSE = 0x10000001
    
    SOCKOPT_OK = 0
    
    SOCKOPT_ERROR = 1
    
    SOCKOPT_ALREADY_CONNECTED = 2
    
    E_ALREADY_COMPLETE = 99999
    
    SSH_AUTH_NONE = 0
    
    SSH_AUTH_PUBLICKEY = (1<<0)
    
    SSH_AUTH_PASSWORD = (1<<1)
    
    SSH_AUTH_HOST = (1<<2)
    
    SSH_AUTH_KEYBOARD = (1<<3)
    
    SSH_AUTH_AGENT = (1<<4)
    
    GSSAPI_DELEGATION_NONE = 0
    
    GSSAPI_DELEGATION_POLICY_FLAG = (1<<0)
    
    GSSAPI_DELEGATION_FLAG = (1<<1)
    
    ERROR_SIZE = 256
    
    SSLOPT_ALLOW_BEAST = (1<<0)
    
    SSLOPT_NO_REVOKE = (1<<1)
    
    HEADER_UNIFIED = 0
    
    HEADER_SEPARATE = (1<<0)
    
    PROTO_HTTP = (1<<0)
    
    PROTO_HTTPS = (1<<1)
    
    PROTO_FTP = (1<<2)
    
    PROTO_FTPS = (1<<3)
    
    PROTO_SCP = (1<<4)
    
    PROTO_SFTP = (1<<5)
    
    PROTO_TELNET = (1<<6)
    
    PROTO_LDAP = (1<<7)
    
    PROTO_LDAPS = (1<<8)
    
    PROTO_DICT = (1<<9)
    
    PROTO_FILE = (1<<10)
    
    PROTO_TFTP = (1<<11)
    
    PROTO_IMAP = (1<<12)
    
    PROTO_IMAPS = (1<<13)
    
    PROTO_POP3 = (1<<14)
    
    PROTO_POP3S = (1<<15)
    
    PROTO_SMTP = (1<<16)
    
    PROTO_SMTPS = (1<<17)
    
    PROTO_RTSP = (1<<18)
    
    PROTO_RTMP = (1<<19)
    
    PROTO_RTMPT = (1<<20)
    
    PROTO_RTMPE = (1<<21)
    
    PROTO_RTMPTE = (1<<22)
    
    PROTO_RTMPS = (1<<23)
    
    PROTO_RTMPTS = (1<<24)
    
    PROTO_GOPHER = (1<<25)
    
    PROTO_SMB = (1<<26)
    
    PROTO_SMBS = (1<<27)
    
    OPTTYPE_LONG = 0
    
    OPTTYPE_OBJECTPOINT = 10000
    
    OPTTYPE_STRINGPOINT = 10000
    
    OPTTYPE_FUNCTIONPOINT = 20000
    
    OPTTYPE_OFF_T = 30000
    
    IPRESOLVE_WHATEVER = 0
    
    IPRESOLVE_V4 = 1
    
    IPRESOLVE_V6 = 2
    
    REDIR_GET_ALL = 0
    
    REDIR_POST_301 = 1
    
    REDIR_POST_302 = 2
    
    REDIR_POST_303 = 4
    
    SSLBACKEND_LIBRESSL = 1
    
    SSLBACKEND_BORINGSSL = 1
    
    SSLBACKEND_WOLFSSL = 6
    
    INFO_STRING = 0x100000
    
    INFO_LONG = 0x200000
    
    INFO_DOUBLE = 0x300000
    
    INFO_SLIST = 0x400000
    
    INFO_SOCKET = 0x500000
    
    INFO_MASK = 0x0fffff
    
    INFO_TYPEMASK = 0xf00000
    
    GLOBAL_SSL = (1<<0)
    
    GLOBAL_WIN32 = (1<<1)
    
    GLOBAL_NOTHING = 0
    
    GLOBAL_ACK_EINTR = (1<<2)
    
    VERSION_IPV6 = (1<<0)
    
    VERSION_KERBEROS4 = (1<<1)
    
    VERSION_SSL = (1<<2)
    
    VERSION_LIBZ = (1<<3)
    
    VERSION_NTLM = (1<<4)
    
    VERSION_GSSNEGOTIATE = (1<<5)
    
    VERSION_DEBUG = (1<<6)
    
    VERSION_ASYNCHDNS = (1<<7)
    
    VERSION_SPNEGO = (1<<8)
    
    VERSION_LARGEFILE = (1<<9)
    
    VERSION_IDN = (1<<10)
    
    VERSION_SSPI = (1<<11)
    
    VERSION_CONV = (1<<12)
    
    VERSION_CURLDEBUG = (1<<13)
    
    VERSION_TLSAUTH_SRP = (1<<14)
    
    VERSION_NTLM_WB = (1<<15)
    
    VERSION_HTTP2 = (1<<16)
    
    VERSION_GSSAPI = (1<<17)
    
    VERSION_KERBEROS5 = (1<<18)
    
    VERSION_UNIX_SOCKETS = (1<<19)
    
    VERSION_PSL = (1<<20)
    
    VERSION_HTTPS_PROXY = (1<<21)
    
    PAUSE_RECV = (1<<0)
    
    PAUSE_RECV_CONT = 0
    
    PAUSE_SEND = (1<<2)
    
    PAUSE_SEND_CONT = 0
    
    # (Not documented)
    # 
    # = Fields:
    # :next_ ::
    #   (FFI::Pointer(*Httppost)) next entry in the list
    # :name ::
    #   (String) pointer to allocated name
    # :namelength ::
    #   (Integer) length of name length
    # :contents ::
    #   (String) pointer to allocated data contents
    # :contentslength ::
    #   (Integer) length of contents field, see also
    #                                          CURL_HTTPPOST_LARGE
    # :buffer ::
    #   (String) pointer to allocated buffer contents
    # :bufferlength ::
    #   (Integer) length of buffer field
    # :contenttype ::
    #   (String) Content-Type
    # :contentheader ::
    #   (FFI::Pointer(*Slist)) list of extra headers for this form
    # :more ::
    #   (FFI::Pointer(*Httppost)) if one field name has more than one
    #                                          file, this link should link to following
    #                                          files
    # :flags ::
    #   (Integer) as defined below
    # :showfilename ::
    #   (String) The file name to show. If not set, the
    #                                          actual file name will be used (if this
    #                                          is a file part)
    # :userp ::
    #   (FFI::Pointer(*Void)) custom pointer used for
    #                                          HTTPPOST_CALLBACK posts
    # :contentlen ::
    #   (Integer) alternative length of contents
    #                                          field. Used if CURL_HTTPPOST_LARGE is
    #                                          set. Added in 7.46.0
    class Httppost < FFI::Struct
      layout :next_, :pointer,
            :name, :string,
            :namelength, :long,
            :contents, :string,
            :contentslength, :long,
            :buffer, :string,
            :bufferlength, :long,
            :contenttype, :string,
            :contentheader, :pointer,
            :more, :pointer,
            :flags, :long,
            :showfilename, :string,
            :userp, :pointer,
            :contentlen, :long
    end
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_progress_callback_(clientp, dltotal, dlnow, ultotal, ulnow)
    # @param [FFI::Pointer(*Void)] clientp 
    # @param [Float] dltotal 
    # @param [Float] dlnow 
    # @param [Float] ultotal 
    # @param [Float] ulnow 
    # @return [FFI::Pointer(*Void)] 
    # @scope class
    callback :progress_callback, [:pointer, :double, :double, :double, :double], :pointer
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_xferinfo_callback_(clientp, dltotal, dlnow, ultotal, ulnow)
    # @param [FFI::Pointer(*Void)] clientp 
    # @param [Integer] dltotal 
    # @param [Integer] dlnow 
    # @param [Integer] ultotal 
    # @param [Integer] ulnow 
    # @return [FFI::Pointer(*Void)] 
    # @scope class
    callback :xferinfo_callback, [:pointer, :long, :long, :long, :long], :pointer
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:curlfiletype).</em>
    # 
    # === Options:
    # :filetype_file ::
    #   
    # :filetype_directory ::
    #   
    # :filetype_symlink ::
    #   
    # :filetype_device_block ::
    #   
    # :filetype_device_char ::
    #   
    # :filetype_namedpipe ::
    #   
    # :filetype_socket ::
    #   
    # :filetype_door ::
    #   
    # :filetype_unknown ::
    #   is possible only on Sun Solaris now
    # 
    # @method _enum_curlfiletype_
    # @return [Symbol]
    # @scope class
    enum :curlfiletype, [
      :filetype_file, 0,
      :filetype_directory, 1,
      :filetype_symlink, 2,
      :filetype_device_block, 3,
      :filetype_device_char, 4,
      :filetype_namedpipe, 5,
      :filetype_socket, 6,
      :filetype_door, 7,
      :filetype_unknown, 8
    ]
    
    # (Not documented)
    # 
    # = Fields:
    # :time ::
    #   (String) If some of these fields is not NULL, it is a pointer to b_data.
    # :perm ::
    #   (String) 
    # :user ::
    #   (String) 
    # :group ::
    #   (String) 
    # :target ::
    #   (String) pointer to the target filename of a symlink
    class FileinfoStrings < FFI::Struct
      layout :time, :string,
            :perm, :string,
            :user, :string,
            :group, :string,
            :target, :string
    end
    
    # (Not documented)
    # 
    # = Fields:
    # :filename ::
    #   (String) 
    # :filetype ::
    #   (Symbol from _enum_curlfiletype_) 
    # :time ::
    #   (Integer) 
    # :perm ::
    #   (Integer) 
    # :uid ::
    #   (Integer) 
    # :gid ::
    #   (Integer) 
    # :size ::
    #   (Integer) 
    # :hardlinks ::
    #   (Integer) 
    # :strings ::
    #   (FileinfoStrings) 
    # :flags ::
    #   (Integer) 
    # :b_data ::
    #   (String) used internally
    # :b_size ::
    #   (unknown) 
    # :b_used ::
    #   (unknown) 
    class Fileinfo < FFI::Struct
      layout :filename, :string,
            :filetype, :curlfiletype,
            :time, :long,
            :perm, :uint,
            :uid, :int,
            :gid, :int,
            :size, :long,
            :hardlinks, :long,
            :strings, FileinfoStrings.by_value,
            :flags, :uint,
            :b_data, :string,
            :b_size, :char,
            :b_used, :char
    end
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_chunk_bgn_callback_(transfer_info, ptr, remains)
    # @param [FFI::Pointer(*Void)] transfer_info 
    # @param [FFI::Pointer(*Void)] ptr 
    # @param [Integer] remains 
    # @return [FFI::Pointer(*Void)] 
    # @scope class
    callback :chunk_bgn_callback, [:pointer, :pointer, :int], :pointer
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_fnmatch_callback_(ptr, pattern, string)
    # @param [FFI::Pointer(*Void)] ptr 
    # @param [String] pattern 
    # @param [String] string 
    # @return [FFI::Pointer(*Void)] 
    # @scope class
    callback :fnmatch_callback, [:pointer, :string, :string], :pointer
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_seek_callback_(instream, offset, origin)
    # @param [FFI::Pointer(*Void)] instream 
    # @param [Integer] offset 
    # @param [Integer] origin 
    # @return [FFI::Pointer(*Void)] 
    # @scope class
    callback :seek_callback, [:pointer, :long, :int], :pointer
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:curlsocktype).</em>
    # 
    # === Options:
    # :socktype_ipcxn ::
    #   
    # :socktype_accept ::
    #   socket created for a specific IP connection
    # :socktype_last ::
    #   socket created by accept() call
    # 
    # @method _enum_curlsocktype_
    # @return [Symbol]
    # @scope class
    enum :curlsocktype, [
      :socktype_ipcxn, 0,
      :socktype_accept, 1,
      :socktype_last, 2
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_sockopt_callback_(clientp, curlfd, purpose)
    # @param [FFI::Pointer(*Void)] clientp 
    # @param [Integer] curlfd 
    # @param [Symbol from _enum_curlsocktype_] purpose 
    # @return [FFI::Pointer(*Void)] 
    # @scope class
    callback :sockopt_callback, [:pointer, :int, :curlsocktype], :pointer
    
    # (Not documented)
    # 
    # = Fields:
    # :family ::
    #   (Integer) 
    # :socktype ::
    #   (Integer) 
    # :protocol ::
    #   (Integer) 
    # :addrlen ::
    #   (Integer) addrlen was a socklen_t type before 7.18.0 but it
    #                              turned really ugly and painful on the systems that
    #                              lack this type
    # :addr ::
    #   (unknown) 
    class Sockaddr < FFI::Struct
      layout :family, :int,
            :socktype, :int,
            :protocol, :int,
            :addrlen, :uint,
            :addr, :char
    end
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_opensocket_callback_(socket_t, clientp, purpose, address)
    # @param [Integer] socket_t 
    # @param [FFI::Pointer(*Void)] clientp 
    # @param [Symbol from _enum_curlsocktype_] purpose 
    # @param [Sockaddr] address 
    # @return [Integer] 
    # @scope class
    callback :opensocket_callback, [:int, :pointer, :curlsocktype, Sockaddr], :int
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_closesocket_callback_(clientp, item)
    # @param [FFI::Pointer(*Void)] clientp 
    # @param [Integer] item 
    # @return [FFI::Pointer(*Void)] 
    # @scope class
    callback :closesocket_callback, [:pointer, :int], :pointer
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:curlioerr).</em>
    # 
    # === Options:
    # :ioe_ok ::
    #   
    # :ioe_unknowncmd ::
    #   I/O operation successful
    # :ioe_failrestart ::
    #   command was unknown to callback
    # :ioe_last ::
    #   failed to restart the read
    # 
    # @method _enum_curlioerr_
    # @return [Symbol]
    # @scope class
    enum :curlioerr, [
      :ioe_ok, 0,
      :ioe_unknowncmd, 1,
      :ioe_failrestart, 2,
      :ioe_last, 3
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:curliocmd).</em>
    # 
    # === Options:
    # :iocmd_nop ::
    #   
    # :iocmd_restartread ::
    #   no operation
    # :iocmd_last ::
    #   restart the read stream from start
    # 
    # @method _enum_curliocmd_
    # @return [Symbol]
    # @scope class
    enum :curliocmd, [
      :iocmd_nop, 0,
      :iocmd_restartread, 1,
      :iocmd_last, 2
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_ioctl_callback_(curlioerr, handle, cmd, clientp)
    # @param [Symbol from _enum_curlioerr_] curlioerr 
    # @param [FFI::Pointer(*)] handle 
    # @param [Integer] cmd 
    # @param [FFI::Pointer(*Void)] clientp 
    # @return [Symbol from _enum_curlioerr_] 
    # @scope class
    callback :ioctl_callback, [:curlioerr, :pointer, :int, :pointer], :curlioerr
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_realloc_callback_(ptr, size)
    # @param [FFI::Pointer(*Void)] ptr 
    # @param [unknown] size 
    # @return [FFI::Pointer(*Void)] 
    # @scope class
    callback :realloc_callback, [:pointer, :char], :pointer
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_calloc_callback_(nmemb, size)
    # @param [unknown] nmemb 
    # @param [unknown] size 
    # @return [unknown] 
    # @scope class
    callback :calloc_callback, [:char, :char], :char
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:infotype).</em>
    # 
    # === Options:
    # :info_text ::
    #   
    # :info_header_in ::
    #   
    # :info_header_out ::
    #   1
    # :info_data_in ::
    #   2
    # :info_data_out ::
    #   3
    # :info_ssl_data_in ::
    #   4
    # :info_ssl_data_out ::
    #   5
    # :info_end ::
    #   6
    # 
    # @method _enum_infotype_
    # @return [Symbol]
    # @scope class
    enum :infotype, [
      :info_text, 0,
      :info_header_in, 1,
      :info_header_out, 2,
      :info_data_in, 3,
      :info_data_out, 4,
      :info_ssl_data_in, 5,
      :info_ssl_data_out, 6,
      :info_end, 7
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_debug_callback_(handle, type, data, size, userptr)
    # @param [FFI::Pointer(*)] handle 
    # @param [Symbol from _enum_infotype_] type 
    # @param [String] data 
    # @param [unknown] size 
    # @param [FFI::Pointer(*Void)] userptr 
    # @return [FFI::Pointer(*)] 
    # @scope class
    callback :debug_callback, [:pointer, :infotype, :string, :char, :pointer], :pointer
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:code).</em>
    # 
    # === Options:
    # :e_ok ::
    #   
    # :e_unsupported_protocol ::
    #   
    # :e_failed_init ::
    #   1
    # :e_url_malformat ::
    #   2
    # :e_not_built_in ::
    #   3
    # :e_couldnt_resolve_proxy ::
    #   4 - (was obsoleted in August 2007 for
    #                                       7.17.0, reused in April 2011 for 7.21.5)
    # :e_couldnt_resolve_host ::
    #   5
    # :e_couldnt_connect ::
    #   6
    # :e_weird_server_reply ::
    #   7
    # :e_remote_access_denied ::
    #   8
    # :e_ftp_accept_failed ::
    #   9 a service was denied by the server
    #                                       due to lack of access - when login fails
    #                                       this is not returned.
    # :e_ftp_weird_pass_reply ::
    #   10 - (was obsoleted in April 2006 for
    #                                       7.15.4, reused in Dec 2011 for 7.24.0)
    # :e_ftp_accept_timeout ::
    #   11
    # :e_ftp_weird_pasv_reply ::
    #   12 - timeout occurred accepting server
    #                                       (was obsoleted in August 2007 for 7.17.0,
    #                                       reused in Dec 2011 for 7.24.0)
    # :e_ftp_weird_227_format ::
    #   13
    # :e_ftp_cant_get_host ::
    #   14
    # :e_http2 ::
    #   15
    # :e_ftp_couldnt_set_type ::
    #   16 - A problem in the http2 framing layer.
    #                                       (was obsoleted in August 2007 for 7.17.0,
    #                                       reused in July 2014 for 7.38.0)
    # :e_partial_file ::
    #   17
    # :e_ftp_couldnt_retr_file ::
    #   18
    # :e_obsolete20 ::
    #   19
    # :e_quote_error ::
    #   20 - NOT USED
    # :e_http_returned_error ::
    #   21 - quote command failure
    # :e_write_error ::
    #   22
    # :e_obsolete24 ::
    #   23
    # :e_upload_failed ::
    #   24 - NOT USED
    # :e_read_error ::
    #   25 - failed upload "command"
    # :e_out_of_memory ::
    #   26 - couldn't open/read from file
    # :e_operation_timedout ::
    #   Note: CURLE_OUT_OF_MEMORY may sometimes indicate a conversion error
    #              instead of a memory allocation error if CURL_DOES_CONVERSIONS
    #              is defined
    # :e_obsolete29 ::
    #   28 - the timeout time was reached
    # :e_ftp_port_failed ::
    #   29 - NOT USED
    # :e_ftp_couldnt_use_rest ::
    #   30 - FTP PORT operation failed
    # :e_obsolete32 ::
    #   31 - the REST command failed
    # :e_range_error ::
    #   32 - NOT USED
    # :e_http_post_error ::
    #   33 - RANGE "command" didn't work
    # :e_ssl_connect_error ::
    #   34
    # :e_bad_download_resume ::
    #   35 - wrong when connecting with SSL
    # :e_file_couldnt_read_file ::
    #   36 - couldn't resume download
    # :e_ldap_cannot_bind ::
    #   37
    # :e_ldap_search_failed ::
    #   38
    # :e_obsolete40 ::
    #   39
    # :e_function_not_found ::
    #   40 - NOT USED
    # :e_aborted_by_callback ::
    #   41 - NOT USED starting with 7.53.0
    # :e_bad_function_argument ::
    #   42
    # :e_obsolete44 ::
    #   43
    # :e_interface_failed ::
    #   44 - NOT USED
    # :e_obsolete46 ::
    #   45 - CURLOPT_INTERFACE failed
    # :e_too_many_redirects ::
    #   46 - NOT USED
    # :e_unknown_option ::
    #   47 - catch endless re-direct loops
    # :e_telnet_option_syntax ::
    #   48 - User specified an unknown option
    # :e_obsolete50 ::
    #   49 - Malformed telnet option
    # :e_peer_failed_verification ::
    #   50 - NOT USED
    # :e_got_nothing ::
    #   51 - peer's certificate or fingerprint
    #                                        wasn't verified fine
    # :e_ssl_engine_notfound ::
    #   52 - when this is a specific error
    # :e_ssl_engine_setfailed ::
    #   53 - SSL crypto engine not found
    # :e_send_error ::
    #   54 - can not set SSL crypto engine as
    #                                       default
    # :e_recv_error ::
    #   55 - failed sending network data
    # :e_obsolete57 ::
    #   56 - failure in receiving network data
    # :e_ssl_certproblem ::
    #   57 - NOT IN USE
    # :e_ssl_cipher ::
    #   58 - problem with the local certificate
    # :e_ssl_cacert ::
    #   59 - couldn't use specified cipher
    # :e_bad_content_encoding ::
    #   60 - problem with the CA cert (path?)
    # :e_ldap_invalid_url ::
    #   61 - Unrecognized/bad encoding
    # :e_filesize_exceeded ::
    #   62 - Invalid LDAP URL
    # :e_use_ssl_failed ::
    #   63 - Maximum file size exceeded
    # :e_send_fail_rewind ::
    #   64 - Requested FTP SSL level failed
    # :e_ssl_engine_initfailed ::
    #   65 - Sending the data requires a rewind
    #                                       that failed
    # :e_login_denied ::
    #   66 - failed to initialise ENGINE
    # :e_tftp_notfound ::
    #   67 - user, password or similar was not
    #                                       accepted and we failed to login
    # :e_tftp_perm ::
    #   68 - file not found on server
    # :e_remote_disk_full ::
    #   69 - permission problem on server
    # :e_tftp_illegal ::
    #   70 - out of disk space on server
    # :e_tftp_unknownid ::
    #   71 - Illegal TFTP operation
    # :e_remote_file_exists ::
    #   72 - Unknown transfer ID
    # :e_tftp_nosuchuser ::
    #   73 - File already exists
    # :e_conv_failed ::
    #   74 - No such user
    # :e_conv_reqd ::
    #   75 - conversion failed
    # :e_ssl_cacert_badfile ::
    #   76 - caller must register conversion
    #                                       callbacks using curl_easy_setopt options
    #                                       CURLOPT_CONV_FROM_NETWORK_FUNCTION,
    #                                       CURLOPT_CONV_TO_NETWORK_FUNCTION, and
    #                                       CURLOPT_CONV_FROM_UTF8_FUNCTION
    # :e_remote_file_not_found ::
    #   77 - could not load CACERT file, missing
    #                                       or wrong format
    # :e_ssh ::
    #   78 - remote file not found
    # :e_ssl_shutdown_failed ::
    #   79 - error from the SSH layer, somewhat
    #                                       generic so the error message will be of
    #                                       interest when this has happened
    # :e_again ::
    #   80 - Failed to shut down the SSL
    #                                       connection
    # :e_ssl_crl_badfile ::
    #   81 - socket is not ready for send/recv,
    #                                       wait till it's ready and try again (Added
    #                                       in 7.18.2)
    # :e_ssl_issuer_error ::
    #   82 - could not load CRL file, missing or
    #                                       wrong format (Added in 7.19.0)
    # :e_ftp_pret_failed ::
    #   83 - Issuer check failed.  (Added in
    #                                       7.19.0)
    # :e_rtsp_cseq_error ::
    #   84 - a PRET command failed
    # :e_rtsp_session_error ::
    #   85 - mismatch of RTSP CSeq numbers
    # :e_ftp_bad_file_list ::
    #   86 - mismatch of RTSP Session Ids
    # :e_chunk_failed ::
    #   87 - unable to parse FTP file list
    # :e_no_connection_available ::
    #   88 - chunk callback reported error
    # :e_ssl_pinnedpubkeynotmatch ::
    #   89 - No connection available, the
    #                                       session will be queued
    # :e_ssl_invalidcertstatus ::
    #   90 - specified pinned public key did not
    #                                        match
    # :e_http2_stream ::
    #   91 - invalid certificate status
    # :last ::
    #   92 - stream error in HTTP/2 framing layer
    # 
    # @method _enum_code_
    # @return [Symbol]
    # @scope class
    enum :code, [
      :e_ok, 0,
      :e_unsupported_protocol, 1,
      :e_failed_init, 2,
      :e_url_malformat, 3,
      :e_not_built_in, 4,
      :e_couldnt_resolve_proxy, 5,
      :e_couldnt_resolve_host, 6,
      :e_couldnt_connect, 7,
      :e_weird_server_reply, 8,
      :e_remote_access_denied, 9,
      :e_ftp_accept_failed, 10,
      :e_ftp_weird_pass_reply, 11,
      :e_ftp_accept_timeout, 12,
      :e_ftp_weird_pasv_reply, 13,
      :e_ftp_weird_227_format, 14,
      :e_ftp_cant_get_host, 15,
      :e_http2, 16,
      :e_ftp_couldnt_set_type, 17,
      :e_partial_file, 18,
      :e_ftp_couldnt_retr_file, 19,
      :e_obsolete20, 20,
      :e_quote_error, 21,
      :e_http_returned_error, 22,
      :e_write_error, 23,
      :e_obsolete24, 24,
      :e_upload_failed, 25,
      :e_read_error, 26,
      :e_out_of_memory, 27,
      :e_operation_timedout, 28,
      :e_obsolete29, 29,
      :e_ftp_port_failed, 30,
      :e_ftp_couldnt_use_rest, 31,
      :e_obsolete32, 32,
      :e_range_error, 33,
      :e_http_post_error, 34,
      :e_ssl_connect_error, 35,
      :e_bad_download_resume, 36,
      :e_file_couldnt_read_file, 37,
      :e_ldap_cannot_bind, 38,
      :e_ldap_search_failed, 39,
      :e_obsolete40, 40,
      :e_function_not_found, 41,
      :e_aborted_by_callback, 42,
      :e_bad_function_argument, 43,
      :e_obsolete44, 44,
      :e_interface_failed, 45,
      :e_obsolete46, 46,
      :e_too_many_redirects, 47,
      :e_unknown_option, 48,
      :e_telnet_option_syntax, 49,
      :e_obsolete50, 50,
      :e_peer_failed_verification, 51,
      :e_got_nothing, 52,
      :e_ssl_engine_notfound, 53,
      :e_ssl_engine_setfailed, 54,
      :e_send_error, 55,
      :e_recv_error, 56,
      :e_obsolete57, 57,
      :e_ssl_certproblem, 58,
      :e_ssl_cipher, 59,
      :e_ssl_cacert, 60,
      :e_bad_content_encoding, 61,
      :e_ldap_invalid_url, 62,
      :e_filesize_exceeded, 63,
      :e_use_ssl_failed, 64,
      :e_send_fail_rewind, 65,
      :e_ssl_engine_initfailed, 66,
      :e_login_denied, 67,
      :e_tftp_notfound, 68,
      :e_tftp_perm, 69,
      :e_remote_disk_full, 70,
      :e_tftp_illegal, 71,
      :e_tftp_unknownid, 72,
      :e_remote_file_exists, 73,
      :e_tftp_nosuchuser, 74,
      :e_conv_failed, 75,
      :e_conv_reqd, 76,
      :e_ssl_cacert_badfile, 77,
      :e_remote_file_not_found, 78,
      :e_ssh, 79,
      :e_ssl_shutdown_failed, 80,
      :e_again, 81,
      :e_ssl_crl_badfile, 82,
      :e_ssl_issuer_error, 83,
      :e_ftp_pret_failed, 84,
      :e_rtsp_cseq_error, 85,
      :e_rtsp_session_error, 86,
      :e_ftp_bad_file_list, 87,
      :e_chunk_failed, 88,
      :e_no_connection_available, 89,
      :e_ssl_pinnedpubkeynotmatch, 90,
      :e_ssl_invalidcertstatus, 91,
      :e_http2_stream, 92,
      :last, 93
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_conv_callback_(code, buffer, length)
    # @param [Symbol from _enum_code_] code 
    # @param [String] buffer 
    # @param [unknown] length 
    # @return [Symbol from _enum_code_] 
    # @scope class
    callback :conv_callback, [:code, :string, :char], :code
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_ssl_ctx_callback_(code, curl, ssl_ctx, userptr)
    # @param [Symbol from _enum_code_] code 
    # @param [FFI::Pointer(*)] curl 
    # @param [FFI::Pointer(*Void)] ssl_ctx 
    # @param [FFI::Pointer(*Void)] userptr 
    # @return [Symbol from _enum_code_] 
    # @scope class
    callback :ssl_ctx_callback, [:code, :pointer, :pointer, :pointer], :code
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:proxytype).</em>
    # 
    # === Options:
    # :proxy_http ::
    #   
    # :proxy_http_1_0 ::
    #   added in 7.10, new in 7.19.4 default is to use
    #                              CONNECT HTTP/1.1
    # :proxy_https ::
    #   added in 7.19.4, force to use CONNECT
    #                                  HTTP/1.0 
    # :proxy_socks4 ::
    #   added in 7.52.0
    # :proxy_socks5 ::
    #   support added in 7.15.2, enum existed already
    #                              in 7.10
    # :proxy_socks4a ::
    #   added in 7.10
    # :proxy_socks5_hostname ::
    #   added in 7.18.0
    # 
    # @method _enum_proxytype_
    # @return [Symbol]
    # @scope class
    enum :proxytype, [
      :proxy_http, 0,
      :proxy_http_1_0, 1,
      :proxy_https, 2,
      :proxy_socks4, 4,
      :proxy_socks5, 5,
      :proxy_socks4a, 6,
      :proxy_socks5_hostname, 7
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:khtype).</em>
    # 
    # === Options:
    # :unknown ::
    #   
    # :rsa1 ::
    #   
    # :rsa ::
    #   
    # :dss ::
    #   
    # 
    # @method _enum_khtype_
    # @return [Symbol]
    # @scope class
    enum :khtype, [
      :unknown, 0,
      :rsa1, 1,
      :rsa, 2,
      :dss, 3
    ]
    
    # (Not documented)
    # 
    # = Fields:
    # :key ::
    #   (String) points to a zero-terminated string encoded with base64
    #                         if len is zero, otherwise to the "raw" data
    # :len ::
    #   (unknown) 
    # :keytype ::
    #   (Symbol from _enum_khtype_) 
    class Khkey < FFI::Struct
      layout :key, :string,
            :len, :char,
            :keytype, :khtype
    end
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:khstat).</em>
    # 
    # === Options:
    # :fine_add_to_file ::
    #   
    # :fine ::
    #   
    # :reject ::
    #   
    # :defer ::
    #   reject the connection, return an error
    # :last ::
    #   do not accept it, but we can't answer right now so
    #                           this causes a CURLE_DEFER error but otherwise the
    #                           connection will be left intact etc
    # 
    # @method _enum_khstat_
    # @return [Symbol]
    # @scope class
    enum :khstat, [
      :fine_add_to_file, 0,
      :fine, 1,
      :reject, 2,
      :defer, 3,
      :last, 4
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:khmatch).</em>
    # 
    # === Options:
    # :ok ::
    #   
    # :mismatch ::
    #   match
    # :missing ::
    #   host found, key mismatch!
    # :last ::
    #   no matching host/key found
    # 
    # @method _enum_khmatch_
    # @return [Symbol]
    # @scope class
    enum :khmatch, [
      :ok, 0,
      :mismatch, 1,
      :missing, 2,
      :last, 3
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_sshkeycallback_(easy, knownkey, foundkey, khmatch, clientp)
    # @param [FFI::Pointer(*)] easy 
    # @param [Khkey] knownkey 
    # @param [Khkey] foundkey 
    # @param [Symbol from _enum_khmatch_] khmatch 
    # @param [FFI::Pointer(*Void)] clientp 
    # @return [FFI::Pointer(*)] 
    # @scope class
    callback :sshkeycallback, [:pointer, Khkey, Khkey, :khmatch, :pointer], :pointer
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:usessl).</em>
    # 
    # === Options:
    # :none ::
    #   
    # :try ::
    #   do not attempt to use SSL
    # :control ::
    #   try using SSL, proceed anyway otherwise
    # :all ::
    #   SSL for the control connection or fail
    # :last ::
    #   SSL for all communication or fail
    # 
    # @method _enum_usessl_
    # @return [Symbol]
    # @scope class
    enum :usessl, [
      :none, 0,
      :try, 1,
      :control, 2,
      :all, 3,
      :last, 4
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ftpccc).</em>
    # 
    # === Options:
    # :ftpssl_ccc_none ::
    #   
    # :ftpssl_ccc_passive ::
    #   do not send CCC
    # :ftpssl_ccc_active ::
    #   Let the server initiate the shutdown
    # :ftpssl_ccc_last ::
    #   Initiate the shutdown
    # 
    # @method _enum_ftpccc_
    # @return [Symbol]
    # @scope class
    enum :ftpccc, [
      :ftpssl_ccc_none, 0,
      :ftpssl_ccc_passive, 1,
      :ftpssl_ccc_active, 2,
      :ftpssl_ccc_last, 3
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ftpauth).</em>
    # 
    # === Options:
    # :default ::
    #   
    # :ssl ::
    #   let libcurl decide
    # :tls ::
    #   use "AUTH SSL"
    # :last ::
    #   use "AUTH TLS"
    # 
    # @method _enum_ftpauth_
    # @return [Symbol]
    # @scope class
    enum :ftpauth, [
      :default, 0,
      :ssl, 1,
      :tls, 2,
      :last, 3
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ftpcreatedir).</em>
    # 
    # === Options:
    # :ftp_create_dir_none ::
    #   
    # :ftp_create_dir ::
    #   do NOT create missing dirs!
    # :ftp_create_dir_retry ::
    #   (FTP/SFTP) if CWD fails, try MKD and then CWD
    #                                  again if MKD succeeded, for SFTP this does
    #                                  similar magic
    # :ftp_create_dir_last ::
    #   (FTP only) if CWD fails, try MKD and then CWD
    #                                  again even if MKD failed!
    # 
    # @method _enum_ftpcreatedir_
    # @return [Symbol]
    # @scope class
    enum :ftpcreatedir, [
      :ftp_create_dir_none, 0,
      :ftp_create_dir, 1,
      :ftp_create_dir_retry, 2,
      :ftp_create_dir_last, 3
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ftpmethod).</em>
    # 
    # === Options:
    # :default ::
    #   
    # :multicwd ::
    #   let libcurl pick
    # :nocwd ::
    #   single CWD operation for each path part
    # :singlecwd ::
    #   no CWD at all
    # :last ::
    #   one CWD to full dir, then work on file
    # 
    # @method _enum_ftpmethod_
    # @return [Symbol]
    # @scope class
    enum :ftpmethod, [
      :default, 0,
      :multicwd, 1,
      :nocwd, 2,
      :singlecwd, 3,
      :last, 4
    ]

    # THIS CODE COMES FROM https://github.com/arthurschreiber/curl-ffi/blob/master/lib/curl/curl.rb  
    OPTION_LONG          = 0
    OPTION_OBJECTPOINT   = 10000
    OPTION_FUNCTIONPOINT = 20000
    OPTION_OFF_T         = 30000

    OPTION = enum :option, [
      # This is the FILE* or void* the regular output should be written to.
      :WRITEDATA, OPTION_OBJECTPOINT + 1,

      # The full URL to get/put
      :URL,  OPTION_OBJECTPOINT + 2,

      # Port number to connect to, if other than default.
      :PORT, OPTION_LONG + 3,

      # Name of proxy to use.
      :PROXY, OPTION_OBJECTPOINT + 4,

      # "name:password" to use when fetching.
      :USERPWD, OPTION_OBJECTPOINT + 5,

      # "name:password" to use with proxy.
      :PROXYUSERPWD, OPTION_OBJECTPOINT + 6,

      # Range to get, specified as an ASCII string.
      :RANGE, OPTION_OBJECTPOINT + 7,

      # Specified file stream to upload from (use as input):
      :INFILE, OPTION_OBJECTPOINT + 9,

      # Buffer to receive error messages in, must be at least CURL_ERROR_SIZE
      # bytes big. If this is not used, error messages go to stderr instead:
      :ERRORBUFFER, OPTION_OBJECTPOINT + 10,

      # Function that will be called to store the output (instead of fwrite). The
      # parameters will use fwrite() syntax, make sure to follow them.
      :WRITEFUNCTION, OPTION_FUNCTIONPOINT + 11,

      # Function that will be called to read the input (instead of fread). The
      # parameters will use fread() syntax, make sure to follow them.
      :READFUNCTION, OPTION_FUNCTIONPOINT + 12,

      # Time-out the read operation after this amount of seconds
      :TIMEOUT, OPTION_LONG + 13,

      # If the CURLOPT_INFILE is used, this can be used to inform libcurl about
      # how large the file being sent really is. That allows better error
      # checking and better verifies that the upload was successful. -1 means
      # unknown size.
      #
      # For large file support, there is also a _LARGE version of the key
      # which takes an off_t type, allowing platforms with larger off_t
      # sizes to handle larger files.  See below for INFILESIZE_LARGE.
      :INFILESIZE, OPTION_LONG + 14,

      # POST static input fields.
      :POSTFIELDS, OPTION_OBJECTPOINT + 15,

      # Set the referrer page (needed by some CGIs)
      :REFERER, OPTION_OBJECTPOINT + 16,

      # Set the FTP PORT string (interface name, named or numerical IP address)
      #   Use i.e '-' to use default address.
      :FTPPORT, OPTION_OBJECTPOINT + 17,

      # Set the User-Agent string (examined by some CGIs)
      :USERAGENT, OPTION_OBJECTPOINT + 18,

      # If the download receives less than "low speed limit" bytes/second
      # during "low speed time" seconds, the operations is aborted.
      # You could i.e if you have a pretty high speed connection, abort if
      # it is less than 2000 bytes/sec during 20 seconds.

      # Set the "low speed limit"
      :LOW_SPEED_LIMIT, OPTION_LONG + 19,

      # Set the "low speed time"
      :LOW_SPEED_TIME, OPTION_LONG + 20,

      # Set the continuation offset.
      #
      # Note there is also a _LARGE version of this key which uses
      # off_t types, allowing for large file offsets on platforms which
      # use larger-than-32-bit off_t's.  Look below for RESUME_FROM_LARGE.
      :RESUME_FROM, OPTION_LONG + 21,

      # Set cookie in request:
      :COOKIE, OPTION_OBJECTPOINT + 22,

      # This points to a linked list of headers, struct curl_slist kind
      :HTTPHEADER, OPTION_OBJECTPOINT + 23,

      # This points to a linked list of post entries, struct curl_httppost
      :HTTPPOST, OPTION_OBJECTPOINT + 24,

      # name of the file keeping your private SSL-certificate
      :SSLCERT, OPTION_OBJECTPOINT + 25,

      # password for the SSL or SSH private key
      :KEYPASSWD, OPTION_OBJECTPOINT + 26,

      # send TYPE parameter?
      :CRLF, OPTION_LONG + 27,

      # send linked-list of QUOTE commands
      :QUOTE, OPTION_OBJECTPOINT + 28,

      # send FILE# or void# to store headers to, if you use a callback it
      #   is simply passed to the callback unmodified
      :WRITEHEADER, OPTION_OBJECTPOINT + 29,

      # point to a file to read the initial cookies from, also enables
      #   "cookie awareness"
      :COOKIEFILE, OPTION_OBJECTPOINT + 31,

      # What version to specifically try to use.
      #   See CURL_SSLVERSION defines below.
      :SSLVERSION, OPTION_LONG + 32,

      # What kind of HTTP time condition to use, see defines
      :TIMECONDITION, OPTION_LONG + 33,

      # Time to use with the above condition. Specified in number of seconds
      #   since 1 Jan 1970
      :TIMEVALUE, OPTION_LONG + 34,

      # Custom request, for customizing the get command like
      #   HTTP: DELETE, TRACE and others
      #   FTP: to use a different list command
      :CUSTOMREQUEST, OPTION_OBJECTPOINT + 36,

      # HTTP request, for odd commands like DELETE, TRACE and others
      :STDERR, OPTION_OBJECTPOINT + 37,

      # send linked-list of post-transfer QUOTE commands
      :POSTQUOTE, OPTION_OBJECTPOINT + 39,

      # Pass a pointer to string of the output using full variable-replacement
      #   as described elsewhere.
      :WRITEINFO, OPTION_OBJECTPOINT + 40,

      :VERBOSE, OPTION_LONG + 41,      # talk a lot
      :HEADER, OPTION_LONG + 42,       # throw the header out too
      :NOPROGRESS, OPTION_LONG + 43,   # shut off the progress meter
      :NOBODY, OPTION_LONG + 44,       # use HEAD to get http document
      :FAILONERROR, OPTION_LONG + 45,  # no output on http error codes >= 300
      :UPLOAD, OPTION_LONG + 46,       # this is an upload
      :POST, OPTION_LONG + 47,         # HTTP POST method
      :DIRLISTONLY, OPTION_LONG + 48,  # return bare names when listing directories

      :APPEND, OPTION_LONG + 50,       # Append instead of overwrite on upload!

      # Specify whether to read the user+password from the .netrc or the URL.
      # This must be one of the CURL_NETRC_* enums below.
      :NETRC, OPTION_LONG + 51,

      :FOLLOWLOCATION, OPTION_LONG + 52,  # use Location: Luke!

      :TRANSFERTEXT, OPTION_LONG + 53, # transfer data in text/ASCII format
      :PUT, OPTION_LONG + 54,          # HTTP PUT

      # 55 = OBSOLETE

      # Function that will be called instead of the internal progress display
      # function. This function should be defined as the curl_progress_callback
      # prototype defines.
      :PROGRESSFUNCTION, OPTION_FUNCTIONPOINT + 56,

      # Data passed to the progress callback
      :PROGRESSDATA, OPTION_OBJECTPOINT + 57,

      # We want the referrer field set automatically when following locations
      :AUTOREFERER, OPTION_LONG + 58,

      # Port of the proxy, can be set in the proxy string as well with:
      #   "[host]:[port]"
      :PROXYPORT, OPTION_LONG + 59,

      # size of the POST input data, if strlen() is not good to use
      :POSTFIELDSIZE, OPTION_LONG + 60,

      # tunnel non-http operations through a HTTP proxy
      :HTTPPROXYTUNNEL, OPTION_LONG + 61,

      # Set the interface string to use as outgoing network interface
      :INTERFACE, OPTION_OBJECTPOINT + 62,

      # Set the krb4/5 security level, this also enables krb4/5 awareness.  This
      # is a string, 'clear', 'safe', 'confidential' or 'private'.  If the string
      # is set but doesn't match one of these, 'private' will be used.
      :KRBLEVEL, OPTION_OBJECTPOINT + 63,

      # Set if we should verify the peer in ssl handshake, set 1 to verify.
      :SSL_VERIFYPEER, OPTION_LONG + 64,

      # The CApath or CAfile used to validate the peer certificate
      #   this option is used only if SSL_VERIFYPEER is true
      :CAINFO, OPTION_OBJECTPOINT + 65,

      # Maximum number of http redirects to follow
      :MAXREDIRS, OPTION_LONG + 68,

      # Pass a OPTION_long set to 1 to get the date of the requested document (if
      #   possible)! Pass a zero to shut it off.
      :FILETIME, OPTION_LONG + 69,

      # This points to a linked list of telnet options
      :TELNETOPTIONS, OPTION_OBJECTPOINT + 70,

      # Max amount of cached alive connections
      :MAXCONNECTS, OPTION_LONG + 71,

      # What policy to use when closing connections when the cache is filled up
      :CLOSEPOLICY, OPTION_LONG + 72,

      # Set to explicitly use a new connection for the upcoming transfer.
      #   Do not use this unless you're absolutely sure of this, as it makes the
      #   operation slower and is less friendly for the network.
      :FRESH_CONNECT, OPTION_LONG + 74,

      # Set to explicitly forbid the upcoming transfer's connection to be re-used
      #   when done. Do not use this unless you're absolutely sure of this, as it
      #   makes the operation slower and is less friendly for the network.
      :FORBID_REUSE, OPTION_LONG + 75,

      # Set to a file name that contains random data for libcurl to use to
      #   seed the random engine when doing SSL connects.
      :RANDOM_FILE, OPTION_OBJECTPOINT + 76,

      # Set to the Entropy Gathering Daemon socket pathname
      :EGDSOCKET, OPTION_OBJECTPOINT + 77,

      # Time-out connect operations after this amount of seconds, if connects
      #   are OK within this time, then fine... This only aborts the connect
      #   phase. [Only works on unix-style/SIGALRM operating systems]
      :CONNECTTIMEOUT, OPTION_LONG + 78,

      # Function that will be called to store headers (instead of fwrite). The
      # parameters will use fwrite() syntax, make sure to follow them.
      :HEADERFUNCTION, OPTION_FUNCTIONPOINT + 79,

      # Set this to force the HTTP request to get back to GET. Only really usable
      #   if POST, PUT or a custom request have been used first.
      :HTTPGET, OPTION_LONG + 80,

      # Set if we should verify the Common name from the peer certificate in ssl
      # handshake, set 1 to check existence, 2 to ensure that it matches the
      # provided hostname.
      :SSL_VERIFYHOST, OPTION_LONG + 81,

      # Specify which file name to write all known cookies in after completed
      #   operation. Set file name to "-" (dash) to make it go to stdout.
      :COOKIEJAR, OPTION_OBJECTPOINT + 82,

      # Specify which SSL ciphers to use
      :SSL_CIPHER_LIST, OPTION_OBJECTPOINT + 83,

      # Specify which HTTP version to use! This must be set to one of the
      #   CURL_HTTP_VERSION* enums set below.
      :HTTP_VERSION, OPTION_LONG + 84,

      # Specifically switch on or off the FTP engine's use of the EPSV command. By
      #   default, that one will always be attempted before the more traditional
      #   PASV command.
      :FTP_USE_EPSV, OPTION_LONG + 85,

      # type of the file keeping your SSL-certificate ("DER", "PEM", "ENG")
      :SSLCERTTYPE, OPTION_OBJECTPOINT + 86,

      # name of the file keeping your private SSL-key
      :SSLKEY, OPTION_OBJECTPOINT + 87,

      # type of the file keeping your private SSL-key ("DER", "PEM", "ENG")
      :SSLKEYTYPE, OPTION_OBJECTPOINT + 88,

      # crypto engine for the SSL-sub system
      :SSLENGINE, OPTION_OBJECTPOINT + 89,

      # set the crypto engine for the SSL-sub system as default
      #   the param has no meaning...
      :SSLENGINE_DEFAULT, OPTION_LONG + 90,

      # Non-zero value means to use the global dns cache
      :DNS_USE_GLOBAL_CACHE, OPTION_LONG + 91, # To become OBSOLETE soon

      # DNS cache timeout
      :DNS_CACHE_TIMEOUT, OPTION_LONG + 92,

      # send linked-list of pre-transfer QUOTE commands
      :PREQUOTE, OPTION_OBJECTPOINT + 93,

      # set the debug function
      :DEBUGFUNCTION, OPTION_FUNCTIONPOINT + 94,

      # set the data for the debug function
      :DEBUGDATA, OPTION_OBJECTPOINT + 95,

      # mark this as start of a cookie session
      :COOKIESESSION, OPTION_LONG + 96,

      # The CApath directory used to validate the peer certificate
      #   this option is used only if SSL_VERIFYPEER is true
      :CAPATH, OPTION_OBJECTPOINT + 97,

      # Instruct libcurl to use a smaller receive buffer
      :BUFFERSIZE, OPTION_LONG + 98,

      # Instruct libcurl to not use any signal/alarm handlers, even when using
      #   timeouts. This option is useful for multi-threaded applications.
      #   See libcurl-the-guide for more background information.
      :NOSIGNAL, OPTION_LONG + 99,

      # Provide a CURLShare for mutexing non-ts data
      :SHARE, OPTION_OBJECTPOINT + 100,

      # indicates type of proxy. accepted values are CURLPROXY_HTTP (default),
      #   CURLPROXY_SOCKS4, CURLPROXY_SOCKS4A and CURLPROXY_SOCKS5.
      :PROXYTYPE, OPTION_LONG + 101,

      # Set the Accept-Encoding string. Use this to tell a server you would like
      #   the response to be compressed.
      :ENCODING, OPTION_OBJECTPOINT + 102,

      # Set pointer to private data
      :PRIVATE, OPTION_OBJECTPOINT + 103,

      # Set aliases for HTTP 200 in the HTTP Response header
      :HTTP200ALIASES, OPTION_OBJECTPOINT + 104,

      # Continue to send authentication (user+password) when following locations,
      #   even when hostname changed. This can potentially send off the name
      #   and password to whatever host the server decides.
      :UNRESTRICTED_AUTH, OPTION_LONG + 105,

      # Specifically switch on or off the FTP engine's use of the EPRT command ( it
      #   also disables the LPRT attempt). By default, those ones will always be
      #   attempted before the good old traditional PORT command.
      :FTP_USE_EPRT, OPTION_LONG + 106,


      # Set this to a bitmask value to enable the particular authentications
      #   methods you like. Use this in combination with CURLOPT_USERPWD.
      #   Note that setting multiple bits may cause extra network round-trips.
      :HTTPAUTH, OPTION_LONG + 107,

      # Set the ssl context callback function, currently only for OpenSSL ssl_ctx
      #   in second argument. The function must be matching the
      #   curl_ssl_ctx_callback proto.
      :SSL_CTX_FUNCTION, OPTION_FUNCTIONPOINT + 108,

      # Set the userdata for the ssl context callback function's third
      #   argument
      :SSL_CTX_DATA, OPTION_OBJECTPOINT + 109,

      # FTP Option that causes missing dirs to be created on the remote server.
      #   In 7.19.4 we introduced the convenience enums for this option using the
      #   CURLFTP_CREATE_DIR prefix.
      :FTP_CREATE_MISSING_DIRS, OPTION_LONG + 110,

      # Set this to a bitmask value to enable the particular authentications
      #   methods you like. Use this in combination with CURLOPT_PROXYUSERPWD.
      #   Note that setting multiple bits may cause extra network round-trips.
      :PROXYAUTH, OPTION_LONG + 111,

      # FTP option that changes the timeout, in seconds, associated with
      #   getting a response.  This is different from transfer timeout time and
      #   essentially places a demand on the FTP server to acknowledge commands
      #   in a timely manner.
      :FTP_RESPONSE_TIMEOUT, OPTION_LONG + 112,
      :CURLOPT_SERVER_RESPONSE_TIMEOUT, OPTION_LONG + 112,

      # Set this option to one of the CURL_IPRESOLVE_* defines (see below) to
      #   tell libcurl to resolve names to those IP versions only. This only has
      #   affect on systems with support for more than one, i.e IPv4 _and_ IPv6.
      :IPRESOLVE, OPTION_LONG + 113,

      # Set this option to limit the size of a file that will be downloaded from
      #   an HTTP or FTP server.

      #   Note there is also _LARGE version which adds large file support for
      #   platforms which have larger off_t sizes.  See MAXFILESIZE_LARGE below.
      :MAXFILESIZE, OPTION_LONG + 114,

      # See the comment for INFILESIZE above, but in short, specifies
      # the size of the file being uploaded.  -1 means unknown.
      :INFILESIZE_LARGE, OPTION_OFF_T + 115,

      # Sets the continuation offset.  There is also a OPTION_LONG version of this;
      # look above for RESUME_FROM.
      :RESUME_FROM_LARGE, OPTION_OFF_T + 116,

      # Sets the maximum size of data that will be downloaded from
      # an HTTP or FTP server.  See MAXFILESIZE above for the OPTION_LONG version.

      :MAXFILESIZE_LARGE, OPTION_OFF_T + 117,

      # Set this option to the file name of your .netrc file you want libcurl
      #   to parse (using the CURLOPT_NETRC option). If not set, libcurl will do
      #   a poor attempt to find the user's home directory and check for a .netrc
      #   file in there.
      :NETRC_FILE, OPTION_OBJECTPOINT + 118,

      # Enable SSL/TLS for FTP, pick one of:
      #   CURLFTPSSL_TRY     - try using SSL, proceed anyway otherwise
      #   CURLFTPSSL_CONTROL - SSL for the control connection or fail
      #   CURLFTPSSL_ALL     - SSL for all communication or fail

      :USE_SSL, OPTION_LONG + 119,

      # The _LARGE version of the standard POSTFIELDSIZE option
      :POSTFIELDSIZE_LARGE, OPTION_OFF_T + 120,

      # Enable/disable the TCP Nagle algorithm
      :TCP_NODELAY, OPTION_LONG + 121,

      # When FTP over SSL/TLS is selected (with CURLOPT_USE_SSL), this option
      #   can be used to change libcurl's default action which is to first try
      #   "AUTH SSL" and then "AUTH TLS" in this order, and proceed when a OK
      #   response has been received.
      #
      #   Available parameters are:
      #   CURLFTPAUTH_DEFAULT - let libcurl decide
      #   CURLFTPAUTH_SSL     - try "AUTH SSL" first, then TLS
      #   CURLFTPAUTH_TLS     - try "AUTH TLS" first, then SSL
      :FTPSSLAUTH, OPTION_LONG + 129,

      :IOCTLFUNCTION, OPTION_FUNCTIONPOINT + 130,
      :IOCTLDATA, OPTION_OBJECTPOINT + 131,

      # zero terminated string for pass on to the FTP server when asked for
      #   "account" info
      :FTP_ACCOUNT, OPTION_OBJECTPOINT + 134,

      # feed cookies into cookie engine
      :COOKIELIST, OPTION_OBJECTPOINT + 135,

      # ignore Content-Length
      :IGNORE_CONTENT_LENGTH, OPTION_LONG + 136,

      # Set to non-zero to skip the IP address received in a 227 PASV FTP server
      #   response. Typically used for FTP-SSL purposes but is not restricted to
      #   that. libcurl will then instead use the same IP address it used for the
      #   control connection.
      :FTP_SKIP_PASV_IP, OPTION_LONG + 137,

      # Select "file method" to use when doing FTP, see the curl_ftpmethod
      #   above.
      :FTP_FILEMETHOD, OPTION_LONG + 138,

      # Local port number to bind the socket to
      :LOCALPORT, OPTION_LONG + 139,

      # Number of ports to try, including the first one set with LOCALPORT.
      #   Thus, setting it to 1 will make no additional attempts but the first.

      :LOCALPORTRANGE, OPTION_LONG + 140,

      # no transfer, set up connection and let application use the socket by
      #   extracting it with CURLINFO_LASTSOCKET
      :CONNECT_ONLY, OPTION_LONG + 141,

      # Function that will be called to convert from the
      #   network encoding (instead of using the iconv calls in libcurl)
      :CONV_FROM_NETWORK_FUNCTION, OPTION_FUNCTIONPOINT + 142,

      # Function that will be called to convert to the
      #   network encoding (instead of using the iconv calls in libcurl)
      :CONV_TO_NETWORK_FUNCTION, OPTION_FUNCTIONPOINT + 143,

      # Function that will be called to convert from UTF8
      #   (instead of using the iconv calls in libcurl)
      #   Note that this is used only for SSL certificate processing
      :CONV_FROM_UTF8_FUNCTION, OPTION_FUNCTIONPOINT + 144,

      # if the connection proceeds too quickly then need to slow it down
      # limit-rate: maximum number of bytes per second to send or receive
      :MAX_SEND_SPEED_LARGE, OPTION_OFF_T + 145,
      :MAX_RECV_SPEED_LARGE, OPTION_OFF_T + 146,

      # Pointer to command string to send if USER/PASS fails.
      :FTP_ALTERNATIVE_TO_USER, OPTION_OBJECTPOINT + 147,

      # callback function for setting socket options
      :SOCKOPTFUNCTION, OPTION_FUNCTIONPOINT + 148,
      :SOCKOPTDATA, OPTION_OBJECTPOINT + 149,

      # set to 0 to disable session ID re-use for this transfer, default is
      #   enabled (== 1)
      :SSL_SESSIONID_CACHE, OPTION_LONG + 150,

      # allowed SSH authentication methods
      :SSH_AUTH_TYPES, OPTION_LONG + 151,

      # Used by scp/sftp to do public/private key authentication
      :SSH_PUBLIC_KEYFILE, OPTION_OBJECTPOINT + 152,
      :SSH_PRIVATE_KEYFILE, OPTION_OBJECTPOINT + 153,

      # Send CCC (Clear Command Channel) after authentication
      :FTP_SSL_CCC, OPTION_LONG + 154,

      # Same as TIMEOUT and CONNECTTIMEOUT, but with ms resolution
      :TIMEOUT_MS, OPTION_LONG + 155,
      :CONNECTTIMEOUT_MS, OPTION_LONG + 156,

      # set to zero to disable the libcurl's decoding and thus pass the raw body
      #   data to the application even when it is encoded/compressed
      :HTTP_TRANSFER_DECODING, OPTION_LONG + 157,
      :HTTP_CONTENT_DECODING, OPTION_LONG + 158,

      # Permission used when creating new files and directories on the remote
      #   server for protocols that support it, SFTP/SCP/FILE
      :NEW_FILE_PERMS, OPTION_LONG + 159,
      :NEW_DIRECTORY_PERMS, OPTION_LONG + 160,

      # Set the behaviour of POST when redirecting. Values must be set to one
      #   of CURL_REDIR* defines below. This used to be called CURLOPT_POST301
      :POSTREDIR, OPTION_LONG + 161,

      # used by scp/sftp to verify the host's public key
      :SSH_HOST_PUBLIC_KEY_MD5, OPTION_OBJECTPOINT + 162,

      # Callback function for opening socket (instead of socket(2)). Optionally,
      #   callback is able change the address or refuse to connect returning
      #   CURL_SOCKET_BAD.  The callback should have type
      #   curl_opensocket_callback
      :OPENSOCKETFUNCTION, OPTION_FUNCTIONPOINT + 163,
      :OPENSOCKETDATA, OPTION_OBJECTPOINT + 164,

      # POST volatile input fields.
      :COPYPOSTFIELDS, OPTION_OBJECTPOINT + 165,

      # set transfer mode (;type=<a|i>) when doing FTP via an HTTP proxy
      :PROXY_TRANSFER_MODE, OPTION_LONG + 166,

      # Callback function for seeking in the input stream
      :SEEKFUNCTION, OPTION_FUNCTIONPOINT + 167,
      :SEEKDATA, OPTION_OBJECTPOINT + 168,

      # CRL file
      :CRLFILE, OPTION_OBJECTPOINT + 169,

      # Issuer certificate
      :ISSUERCERT, OPTION_OBJECTPOINT + 170,

      # (IPv6) Address scope
      :ADDRESS_SCOPE, OPTION_LONG + 171,

      # Collect certificate chain info and allow it to get retrievable with
      #   CURLINFO_CERTINFO after the transfer is complete. (Unfortunately) only
      #   working with OpenSSL-powered builds.
      :CERTINFO, OPTION_LONG + 172,

      # "name" and "pwd" to use when fetching.
      :USERNAME, OPTION_OBJECTPOINT + 173,
      :PASSWORD, OPTION_OBJECTPOINT + 174,

        # "name" and "pwd" to use with Proxy when fetching.
      :PROXYUSERNAME, OPTION_OBJECTPOINT + 175,
      :PROXYPASSWORD, OPTION_OBJECTPOINT + 176,

      # Comma separated list of hostnames defining no-proxy zones. These should
      #   match both hostnames directly, and hostnames within a domain. For
      #   example, local.com will match local.com and www.local.com, but NOT
      #   notlocal.com or www.notlocal.com. For compatibility with other
      #   implementations of this, .local.com will be considered to be the same as
      #   local.com. A single# is the only valid wildcard, and effectively
      #   disables the use of proxy.
      :NOPROXY, OPTION_OBJECTPOINT + 177,

      # block size for TFTP transfers
      :TFTP_BLKSIZE, OPTION_LONG + 178,

      # Socks Service
      :SOCKS5_GSSAPI_SERVICE, OPTION_OBJECTPOINT + 179,

      # Socks Service
      :SOCKS5_GSSAPI_NEC, OPTION_LONG + 180,

      # set the bitmask for the protocols that are allowed to be used for the
      #   transfer, which thus helps the app which takes URLs from users or other
      #   external inputs and want to restrict what protocol(s) to deal
      #   with. Defaults to CURLPROTO_ALL.
      :PROTOCOLS, OPTION_LONG + 181,

      # set the bitmask for the protocols that libcurl is allowed to follow to,
      #   as a subset of the CURLOPT_PROTOCOLS ones. That means the protocol needs
      #   to be set in both bitmasks to be allowed to get redirected to. Defaults
      #   to all protocols except FILE and SCP.
      :REDIR_PROTOCOLS, OPTION_LONG + 182,

      # set the SSH knownhost file name to use
      :SSH_KNOWNHOSTS, OPTION_OBJECTPOINT + 183,

      # set the SSH host key callback, must point to a curl_sshkeycallback
      #   function
      :SSH_KEYFUNCTION, OPTION_FUNCTIONPOINT + 184,

      # set the SSH host key callback custom pointer
      :SSH_KEYDATA, OPTION_OBJECTPOINT + 185,

      # set the SMTP mail originator
      :MAIL_FROM, OPTION_OBJECTPOINT + 186,

      # set the SMTP mail receiver(s)
      :MAIL_RCPT, OPTION_OBJECTPOINT + 187,

      # FTP: send PRET before PASV
      :FTP_USE_PRET, OPTION_LONG + 188,

      # RTSP request method (OPTIONS, SETUP, PLAY, etc...)
      :RTSP_REQUEST, OPTION_LONG + 189,

      # The RTSP session identifier
      :RTSP_SESSION_ID, OPTION_OBJECTPOINT + 190,

      # The RTSP stream URI
      :RTSP_STREAM_URI, OPTION_OBJECTPOINT + 191,

      # The Transport: header to use in RTSP requests
      :RTSP_TRANSPORT, OPTION_OBJECTPOINT + 192,

      # Manually initialize the client RTSP CSeq for this handle
      :RTSP_CLIENT_CSEQ, OPTION_LONG + 193,

      # Manually initialize the server RTSP CSeq for this handle
      :RTSP_SERVER_CSEQ, OPTION_LONG + 194,

      # The stream to pass to INTERLEAVEFUNCTION.
      :INTERLEAVEDATA, OPTION_OBJECTPOINT + 195,

      # Let the application define a custom write method for RTP data
      :INTERLEAVEFUNCTION, OPTION_FUNCTIONPOINT + 196,

      # Turn on wildcard matching
      :WILDCARDMATCH, OPTION_LONG + 197,

      # Directory matching callback called before downloading of an
      #   individual file (chunk) started
      :CHUNK_BGN_FUNCTION, OPTION_FUNCTIONPOINT + 198,

      # Directory matching callback called after the file (chunk)
      #   was downloaded, or skipped
      :CHUNK_END_FUNCTION, OPTION_FUNCTIONPOINT + 199,

      # Change match (fnmatch-like) callback for wildcard matching
      :FNMATCH_FUNCTION, OPTION_FUNCTIONPOINT + 200,

      # Let the application define custom chunk data pointer
      :CHUNK_DATA, OPTION_OBJECTPOINT + 201,

      # FNMATCH_FUNCTION user pointer
      :FNMATCH_DATA, OPTION_OBJECTPOINT + 202,
    ]

    MULTI_OPTION = enum :multi_option, [
      :SOCKETFUNCTION, 1 + OPTION_FUNCTIONPOINT,
      :SOCKETDATA,     2 + OPTION_OBJECTPOINT,
      :PIPELINING,     3 + OPTION_LONG,
      :TIMERFUNCTION,  4 + OPTION_FUNCTIONPOINT,
      :TIMERDATA,      5 + OPTION_OBJECTPOINT,
      :MAXCONNECTS,    6 + OPTION_LONG
    ]

    INFO = enum :info, [
      :EFFECTIVE_URL,           INFO_STRING + 1,
      :RESPONSE_CODE,           INFO_LONG   + 2,
      :TOTAL_TIME,              INFO_DOUBLE + 3,
      :NAMELOOKUP_TIME,         INFO_DOUBLE + 4,
      :CONNECT_TIME,            INFO_DOUBLE + 5,
      :PRETRANSFER_TIME,        INFO_DOUBLE + 6,
      :SIZE_UPLOAD,             INFO_DOUBLE + 7,
      :SIZE_DOWNLOAD,           INFO_DOUBLE + 8,
      :SPEED_DOWNLOAD,          INFO_DOUBLE + 9,
      :SPEED_UPLOAD,            INFO_DOUBLE + 10,
      :HEADER_SIZE,             INFO_LONG   + 11,
      :REQUEST_SIZE,            INFO_LONG   + 12,
      :SSL_VERIFYRESULT,        INFO_LONG   + 13,
      :FILETIME,                INFO_LONG   + 14,
      :CONTENT_LENGTH_DOWNLOAD, INFO_DOUBLE + 15,
      :CONTENT_LENGTH_UPLOAD,   INFO_DOUBLE + 16,
      :STARTTRANSFER_TIME,      INFO_DOUBLE + 17,
      :CONTENT_TYPE,            INFO_STRING + 18,
      :REDIRECT_TIME,           INFO_DOUBLE + 19,
      :REDIRECT_COUNT,          INFO_LONG   + 20,
      :PRIVATE,                 INFO_STRING + 21,
      :HTTP_CONNECTCODE,        INFO_LONG   + 22,
      :HTTPAUTH_AVAIL,          INFO_LONG   + 23,
      :PROXYAUTH_AVAIL,         INFO_LONG   + 24,
      :OS_ERRNO,                INFO_LONG   + 25,
      :NUM_CONNECTS,            INFO_LONG   + 26,
      :SSL_ENGINES,             INFO_SLIST  + 27,
      :COOKIELIST,              INFO_SLIST  + 28,
      :LASTSOCKET,              INFO_LONG   + 29,
      :FTP_ENTRY_PATH,          INFO_STRING + 30,
      :REDIRECT_URL,            INFO_STRING + 31,
      :PRIMARY_IP,              INFO_STRING + 32,
      :APPCONNECT_TIME,         INFO_DOUBLE + 33,
      :CERTINFO,                INFO_SLIST  + 34,
      :CONDITION_UNMET,         INFO_LONG   + 35,
      :RTSP_SESSION_ID,         INFO_STRING + 36,
      :RTSP_CLIENT_CSEQ,        INFO_LONG   + 37,
      :RTSP_SERVER_CSEQ,        INFO_LONG   + 38,
      :RTSP_CSEQ_RECV,          INFO_LONG   + 39,
      :PRIMARY_PORT,            INFO_LONG   + 40,
      :LOCAL_IP,                INFO_STRING + 41,
      :LOCAL_PORT,              INFO_LONG   + 42
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:netrc_option).</em>
    # 
    # === Options:
    # :ignored ::
    #   The .netrc will never be read.
    #   This is the default.
    # :optional ::
    #   A user:password in the URL will be preferred
    #   to one in the .netrc.
    # :required ::
    #   A user:password in the URL will be ignored.
    #   Unless one is set programmatically, the .netrc
    #   will be queried.
    # 
    # @method _enum_netrc_option_
    # @return [Symbol]
    # @scope class
    enum :netrc_option, [
      :ignored, 0,
      :optional, 1,
      :required, 2,
      :last, 3
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:tlsauth).</em>
    # 
    # === Options:
    # :none ::
    #   
    # :srp ::
    #   
    # :last ::
    #   
    # 
    # @method _enum_tlsauth_
    # @return [Symbol]
    # @scope class
    enum :tlsauth, [
      :none, 0,
      :srp, 1,
      :last, 2
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:time_cond).</em>
    # 
    # === Options:
    # :timecond_none ::
    #   
    # :timecond_ifmodsince ::
    #   
    # :timecond_ifunmodsince ::
    #   
    # :timecond_lastmod ::
    #   
    # :timecond_last ::
    #   
    # 
    # @method _enum_time_cond_
    # @return [Symbol]
    # @scope class
    enum :time_cond, [
      :timecond_none, 0,
      :timecond_ifmodsince, 1,
      :timecond_ifunmodsince, 2,
      :timecond_lastmod, 3,
      :timecond_last, 4
    ]
    
    # (Not documented)
    # 
    # @method strequal(s1, s2)
    # @param [String] s1 
    # @param [String] s2 
    # @return [Integer] 
    # @scope class
    attach_function :strequal, :curl_strequal, [:string, :string], :int
    
    # (Not documented)
    # 
    # @method strnequal(s1, s2, n)
    # @param [String] s1 
    # @param [String] s2 
    # @param [unknown] n 
    # @return [Integer] 
    # @scope class
    attach_function :strnequal, :curl_strnequal, [:string, :string, :char], :int
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:formoption).</em>
    # 
    # === Options:
    # :form_nothing ::
    #   
    # :form_copyname ::
    #   
    # :form_ptrname ::
    #   
    # :form_namelength ::
    #   
    # :form_copycontents ::
    #   
    # :form_ptrcontents ::
    #   
    # :form_contentslength ::
    #   
    # :form_filecontent ::
    #   
    # :form_array ::
    #   
    # :form_obsolete ::
    #   
    # :form_file ::
    #   
    # :form_buffer ::
    #   
    # :form_bufferptr ::
    #   
    # :form_bufferlength ::
    #   
    # :form_contenttype ::
    #   
    # :form_contentheader ::
    #   
    # :form_filename ::
    #   
    # :form_end ::
    #   
    # :form_obsolete2 ::
    #   
    # :form_stream ::
    #   
    # :form_contentlen ::
    #   
    # :form_lastentry ::
    #   
    # 
    # @method _enum_formoption_
    # @return [Symbol]
    # @scope class
    enum :formoption, [
      :form_nothing, 0,
      :form_copyname, 1,
      :form_ptrname, 2,
      :form_namelength, 3,
      :form_copycontents, 4,
      :form_ptrcontents, 5,
      :form_contentslength, 6,
      :form_filecontent, 7,
      :form_array, 8,
      :form_obsolete, 9,
      :form_file, 10,
      :form_buffer, 11,
      :form_bufferptr, 12,
      :form_bufferlength, 13,
      :form_contenttype, 14,
      :form_contentheader, 15,
      :form_filename, 16,
      :form_end, 17,
      :form_obsolete2, 18,
      :form_stream, 19,
      :form_contentlen, 20,
      :form_lastentry, 21
    ]
    
    # (Not documented)
    # 
    # = Fields:
    # :option ::
    #   (Symbol from _enum_formoption_) 
    # :value ::
    #   (String) 
    class Forms < FFI::Struct
      layout :option, :formoption,
            :value, :string
    end
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:for_mcode).</em>
    # 
    # === Options:
    # :formadd_ok ::
    #   
    # :formadd_memory ::
    #   first, no error
    # :formadd_option_twice ::
    #   
    # :formadd_null ::
    #   
    # :formadd_unknown_option ::
    #   
    # :formadd_incomplete ::
    #   
    # :formadd_illegal_array ::
    #   
    # :formadd_disabled ::
    #   
    # :formadd_last ::
    #   libcurl was built with this disabled
    # 
    # @method _enum_for_mcode_
    # @return [Symbol]
    # @scope class
    enum :for_mcode, [
      :formadd_ok, 0,
      :formadd_memory, 1,
      :formadd_option_twice, 2,
      :formadd_null, 3,
      :formadd_unknown_option, 4,
      :formadd_incomplete, 5,
      :formadd_illegal_array, 6,
      :formadd_disabled, 7,
      :formadd_last, 8
    ]
    
    # (Not documented)
    # 
    # @method formadd(httppost, last_post)
    # @param [FFI::Pointer(**Httppost)] httppost 
    # @param [FFI::Pointer(**Httppost)] last_post 
    # @return [Symbol from _enum_for_mcode_] 
    # @scope class
    attach_function :formadd, :curl_formadd, [:pointer, :pointer], :for_mcode
    
    # (Not documented)
    # 
    # @method formget(form, arg, append)
    # @param [Httppost] form 
    # @param [FFI::Pointer(*Void)] arg 
    # @param [FFI::Pointer(FormgetCallback)] append 
    # @return [Integer] 
    # @scope class
    attach_function :formget, :curl_formget, [Httppost, :pointer, :pointer], :int
    
    # (Not documented)
    # 
    # @method formfree(form)
    # @param [Httppost] form 
    # @return [nil] 
    # @scope class
    attach_function :formfree, :curl_formfree, [Httppost], :void
    
    # (Not documented)
    # 
    # @method getenv(variable)
    # @param [String] variable 
    # @return [String] 
    # @scope class
    attach_function :getenv, :curl_getenv, [:string], :string
    
    # (Not documented)
    # 
    # @method version()
    # @return [String] 
    # @scope class
    attach_function :version, :curl_version, [], :string
    
    # (Not documented)
    # 
    # @method easy_escape(handle, string, length)
    # @param [FFI::Pointer(*)] handle 
    # @param [String] string 
    # @param [Integer] length 
    # @return [String] 
    # @scope class
    attach_function :easy_escape, :curl_easy_escape, [:pointer, :string, :int], :string
    
    # (Not documented)
    # 
    # @method escape(string, length)
    # @param [String] string 
    # @param [Integer] length 
    # @return [String] 
    # @scope class
    attach_function :escape, :curl_escape, [:string, :int], :string
    
    # (Not documented)
    # 
    # @method easy_unescape(handle, string, length, outlength)
    # @param [FFI::Pointer(*)] handle 
    # @param [String] string 
    # @param [Integer] length 
    # @param [FFI::Pointer(*Int)] outlength 
    # @return [String] 
    # @scope class

    # Returns a char * that has to be freed using curl_free
    attach_function :easy_unescape, :curl_easy_unescape, [:pointer, :string, :int, :pointer], :pointer
    
    # (Not documented)
    # 
    # @method unescape(string, length)
    # @param [String] string 
    # @param [Integer] length 
    # @return [String] 
    # @scope class
    #attach_function :unescape, :curl_unescape, [:string, :int], :string
    
    # Returns a char * that has to be freed using curl_free
    attach_function :unescape, :curl_unescape, [:string, :int], :pointer
    
    # (Not documented)
    # 
    # @method free(p)
    # @param [FFI::Pointer(*Void)] p 
    # @return [nil] 
    # @scope class
    attach_function :free, :curl_free, [:pointer], :void
    
    # (Not documented)
    # 
    # @method global_init(flags)
    # @param [Integer] flags 
    # @return [Symbol from _enum_code_] 
    # @scope class
    attach_function :global_init, :curl_global_init, [:long], :code
    
    # (Not documented)
    # 
    # @method global_init_mem(flags, m, f, r, s, c)
    # @param [Integer] flags 
    # @param [FFI::Pointer(MallocCallback)] m 
    # @param [FFI::Pointer(FreeCallback)] f 
    # @param [Proc(_callback_realloc_callback_)] r 
    # @param [FFI::Pointer(StrdupCallback)] s 
    # @param [Proc(_callback_calloc_callback_)] c 
    # @return [Symbol from _enum_code_] 
    # @scope class
    attach_function :global_init_mem, :curl_global_init_mem, [:long, :pointer, :pointer, :realloc_callback, :pointer, :calloc_callback], :code
    
    # (Not documented)
    # 
    # @method global_cleanup()
    # @return [nil] 
    # @scope class
    attach_function :global_cleanup, :curl_global_cleanup, [], :void
    
    # (Not documented)
    # 
    # = Fields:
    # :data ::
    #   (String) 
    # :next_ ::
    #   (FFI::Pointer(*Slist)) 
    module SlistWrappers
      # @param [String] string 
      # @return [Slist] 
      def append(string)
        Slist.new CurlFFI.slist_append(self, string)
      end
      
      # @return [nil] 
      def free_all()
        CurlFFI.slist_free_all(self)
      end
    end
    
    class Slist < FFI::Struct
      include SlistWrappers
      layout :data, :string,
            :next_, :pointer
    end
    
    # (Not documented)
    # 
    # @method slist_append(slist, string)
    # @param [Slist] slist 
    # @param [String] string 
    # @return [Slist] 
    # @scope class
    attach_function :slist_append, :curl_slist_append, [Slist, :string], Slist
    
    # (Not documented)
    # 
    # @method slist_free_all(slist)
    # @param [Slist] slist 
    # @return [nil] 
    # @scope class
    attach_function :slist_free_all, :curl_slist_free_all, [Slist], :void
    
    # (Not documented)
    # 
    # @method getdate(p, unused)
    # @param [String] p 
    # @param [FFI::Pointer(*TimeT)] unused 
    # @return [Integer] 
    # @scope class
    attach_function :getdate, :curl_getdate, [:string, :pointer], :long
    
    # (Not documented)
    # 
    # = Fields:
    # :num_of_certs ::
    #   (Integer) number of certificates with information
    # :certinfo ::
    #   (FFI::Pointer(**Slist)) for each index in this array, there's a
    #                                      linked list with textual information in the
    #                                      format "name: value"
    class Certinfo < FFI::Struct
      layout :num_of_certs, :int,
            :certinfo, :pointer
    end
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:sslbackend).</em>
    # 
    # === Options:
    # :none ::
    #   
    # :openssl ::
    #   
    # :gnutls ::
    #   
    # :nss ::
    #   
    # :obsolete4 ::
    #   
    # :gskit ::
    #   Was QSOSSL.
    # :polarssl ::
    #   
    # :cyassl ::
    #   
    # :schannel ::
    #   
    # :darwinssl ::
    #   
    # :axtls ::
    #   
    # :mbedtls ::
    #   
    # 
    # @method _enum_sslbackend_
    # @return [Symbol]
    # @scope class
    enum :sslbackend, [
      :none, 0,
      :openssl, 1,
      :gnutls, 2,
      :nss, 3,
      :obsolete4, 4,
      :gskit, 5,
      :polarssl, 6,
      :cyassl, 7,
      :schannel, 8,
      :darwinssl, 9,
      :axtls, 10,
      :mbedtls, 11
    ]
    
    # (Not documented)
    # 
    # = Fields:
    # :backend ::
    #   (Symbol from _enum_sslbackend_) 
    # :internals ::
    #   (FFI::Pointer(*Void)) 
    class Tlssessioninfo < FFI::Struct
      layout :backend, :sslbackend,
            :internals, :pointer
    end
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:closepolicy).</em>
    # 
    # === Options:
    # :none ::
    #   
    # :oldest ::
    #   first, never use this
    # :least_recently_used ::
    #   
    # :least_traffic ::
    #   
    # :slowest ::
    #   
    # :callback ::
    #   
    # :last ::
    #   
    # 
    # @method _enum_closepolicy_
    # @return [Symbol]
    # @scope class
    enum :closepolicy, [
      :none, 0,
      :oldest, 1,
      :least_recently_used, 2,
      :least_traffic, 3,
      :slowest, 4,
      :callback, 5,
      :last, 6
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:lock_data).</em>
    # 
    # === Options:
    # :none ::
    #   
    # :share ::
    #   CURL_LOCK_DATA_SHARE is used internally to say that
    #   the locking is just made to change the internal state of the share
    #   itself.
    # :cookie ::
    #   
    # :dns ::
    #   
    # :ssl_session ::
    #   
    # :connect ::
    #   
    # :last ::
    #   
    # 
    # @method _enum_lock_data_
    # @return [Symbol]
    # @scope class
    enum :lock_data, [
      :none, 0,
      :share, 1,
      :cookie, 2,
      :dns, 3,
      :ssl_session, 4,
      :connect, 5,
      :last, 6
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:lock_access).</em>
    # 
    # === Options:
    # :none ::
    #   
    # :shared ::
    #   unspecified action
    # :single ::
    #   for read perhaps
    # :last ::
    #   for write perhaps
    # 
    # @method _enum_lock_access_
    # @return [Symbol]
    # @scope class
    enum :lock_access, [
      :none, 0,
      :shared, 1,
      :single, 2,
      :last, 3
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_lock_function_(handle, data, locktype, userptr)
    # @param [FFI::Pointer(*)] handle 
    # @param [Symbol from _enum_lock_data_] data 
    # @param [Symbol from _enum_lock_access_] locktype 
    # @param [FFI::Pointer(*Void)] userptr 
    # @return [FFI::Pointer(*)] 
    # @scope class
    callback :lock_function, [:pointer, :lock_data, :lock_access, :pointer], :pointer
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method.</em>
    # 
    # @method _callback_unlock_function_(handle, data, userptr)
    # @param [FFI::Pointer(*)] handle 
    # @param [Symbol from _enum_lock_data_] data 
    # @param [FFI::Pointer(*Void)] userptr 
    # @return [FFI::Pointer(*)] 
    # @scope class
    callback :unlock_function, [:pointer, :lock_data, :pointer], :pointer
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:s_hcode).</em>
    # 
    # === Options:
    # :she_ok ::
    #   
    # :she_bad_option ::
    #   all is fine
    # :she_in_use ::
    #   1
    # :she_invalid ::
    #   2
    # :she_nomem ::
    #   3
    # :she_not_built_in ::
    #   4 out of memory
    # :she_last ::
    #   5 feature not present in lib
    # 
    # @method _enum_s_hcode_
    # @return [Symbol]
    # @scope class
    enum :s_hcode, [
      :she_ok, 0,
      :she_bad_option, 1,
      :she_in_use, 2,
      :she_invalid, 3,
      :she_nomem, 4,
      :she_not_built_in, 5,
      :she_last, 6
    ]
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:s_hoption).</em>
    # 
    # === Options:
    # :shopt_none ::
    #   
    # :shopt_share ::
    #   don't use
    # :shopt_unshare ::
    #   specify a data type to share
    # :shopt_lockfunc ::
    #   specify which data type to stop sharing
    # :shopt_unlockfunc ::
    #   pass in a 'curl_lock_function' pointer
    # :shopt_userdata ::
    #   pass in a 'curl_unlock_function' pointer
    # :shopt_last ::
    #   pass in a user data pointer used in the lock/unlock
    #                              callback functions
    # 
    # @method _enum_s_hoption_
    # @return [Symbol]
    # @scope class
    enum :s_hoption, [
      :shopt_none, 0,
      :shopt_share, 1,
      :shopt_unshare, 2,
      :shopt_lockfunc, 3,
      :shopt_unlockfunc, 4,
      :shopt_userdata, 5,
      :shopt_last, 6
    ]
    
    # (Not documented)
    # 
    # @method share_init()
    # @return [FFI::Pointer(*SH)] 
    # @scope class
    attach_function :share_init, :curl_share_init, [], :pointer
    
    # (Not documented)
    # 
    # @method share_setopt(sh, option)
    # @param [FFI::Pointer(*SH)] sh 
    # @param [Symbol from _enum_s_hoption_] option 
    # @return [Symbol from _enum_s_hcode_] 
    # @scope class
    attach_function :share_setopt, :curl_share_setopt, [:pointer, :s_hoption], :s_hcode
    
    # (Not documented)
    # 
    # @method share_cleanup(sh)
    # @param [FFI::Pointer(*SH)] sh 
    # @return [Symbol from _enum_s_hcode_] 
    # @scope class
    attach_function :share_cleanup, :curl_share_cleanup, [:pointer], :s_hcode
    
    # (Not documented)
    # 
    # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:version).</em>
    # 
    # === Options:
    # :first ::
    #   
    # :second ::
    #   
    # :third ::
    #   
    # :fourth ::
    #   
    # :last ::
    #   
    # 
    # @method _enum_version_
    # @return [Symbol]
    # @scope class
    enum :version, [
      :first, 0,
      :second, 1,
      :third, 2,
      :fourth, 3,
      :last, 4
    ]
    
    # (Not documented)
    # 
    # = Fields:
    # :age ::
    #   (Symbol from _enum_version_) age of the returned struct
    # :version ::
    #   (String) LIBCURL_VERSION
    # :version_num ::
    #   (Integer) LIBCURL_VERSION_NUM
    # :host ::
    #   (String) OS/host/cpu/machine when configured
    # :features ::
    #   (Integer) bitmask, see defines below
    # :ssl_version ::
    #   (String) human readable string
    # :ssl_version_num ::
    #   (Integer) not used anymore, always 0
    # :libz_version ::
    #   (String) human readable string
    # :protocols ::
    #   (FFI::Pointer(**CharS)) protocols is terminated by an entry with a NULL protoname
    # :ares ::
    #   (String) The fields below this were added in CURLVERSION_SECOND
    # :ares_num ::
    #   (Integer) 
    # :libidn ::
    #   (String) This field was added in CURLVERSION_THIRD
    # :iconv_ver_num ::
    #   (Integer) Same as '_libiconv_version' if built with HAVE_ICONV
    # :libssh_version ::
    #   (String) human readable string
    class VersionInfoData < FFI::Struct
      layout :age, :version,
            :version, :string,
            :version_num, :uint,
            :host, :string,
            :features, :int,
            :ssl_version, :string,
            :ssl_version_num, :long,
            :libz_version, :string,
            :protocols, :pointer,
            :ares, :string,
            :ares_num, :int,
            :libidn, :string,
            :iconv_ver_num, :int,
            :libssh_version, :string
    end
    
    # (Not documented)
    # 
    # @method version_info(version)
    # @param [Symbol from _enum_version_] version 
    # @return [VersionInfoData] 
    # @scope class
    attach_function :version_info, :curl_version_info, [:version], VersionInfoData
    
    # (Not documented)
    # 
    # @method easy_strerror(code)
    # @param [Symbol from _enum_code_] code 
    # @return [String] 
    # @scope class
    attach_function :easy_strerror, :curl_easy_strerror, [:code], :string
    
    # (Not documented)
    # 
    # @method share_strerror(s_hcode)
    # @param [Symbol from _enum_s_hcode_] s_hcode 
    # @return [String] 
    # @scope class
    attach_function :share_strerror, :curl_share_strerror, [:s_hcode], :string
    
    # (Not documented)
    # 
    # @method easy_pause(handle, bitmask)
    # @param [FFI::Pointer(*)] handle 
    # @param [Integer] bitmask 
    # @return [Symbol from _enum_code_] 
    # @scope class
    attach_function :easy_pause, :curl_easy_pause, [:pointer, :int], :code
    
    #                                  _   _ ____  _
    #  Project                     ___| | | |  _ \| |
    #                             / __| | | | |_) | |
    #                            | (__| |_| |  _ <| |___
    #                             \___|\___/|_| \_\_____|
    # 
    # Copyright (C) 1998 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al.
    # 
    # This software is licensed as described in the file COPYING, which
    # you should have received as part of this distribution. The terms
    # are also available at https://curl.haxx.se/docs/copyright.html.
    # 
    # You may opt to use, copy, modify, merge, publish, distribute and/or sell
    # copies of the Software, and permit persons to whom the Software is
    # furnished to do so, under the terms of the COPYING file.
    # 
    # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
    # KIND, either express or implied.
    # 
    # @method easy_init()
    # @return [FFI::Pointer(*)] 
    # @scope class
    attach_function :easy_init, :curl_easy_init, [], :pointer
    
    # (Not documented)
    # 
    # @method easy_setopt(curl, option)
    # @param [FFI::Pointer(*)] curl 
    # @param [Symbol from _enum_option_] option 
    # @return [Symbol from _enum_code_] 
    # @scope class
    # attach_function :easy_setopt, :curl_easy_setopt, [:pointer, :option, :pointer], :code

    # THIS CODE COMES FROM https://github.com/arthurschreiber/curl-ffi/blob/master/lib/curl/curl.rb
    # @todo This might have to be changed for different systems
    typedef :long_long, :curl_off_t

    # function callbacks to be passed to opts
    callback :string_function, [:string, :size_t, :size_t, :pointer], :size_t
    callback :progress_function, [:pointer, :double, :double, :double, :double], :int

    attach_function :easy_setopt_long, :curl_easy_setopt, [:pointer, :option, :long], :code
    attach_function :easy_setopt_string, :curl_easy_setopt, [:pointer, :option, :string], :code
    attach_function :easy_setopt_pointer, :curl_easy_setopt, [:pointer, :option, :pointer], :code
    attach_function :easy_setopt_curl_off_t, :curl_easy_setopt, [:pointer, :option, :curl_off_t], :code

    # Callback-supporting opts
    attach_function :easy_setopt_string_function, :curl_easy_setopt, [:pointer, :option, :string_function], :code
    attach_function :easy_setopt_progress_function, :curl_easy_setopt, [:pointer, :option, :progress_function], :code
    

    # TODO this appears broken
    def self.easy_setopt(handle, option, value)
      # TODO can remove this after debugging if perf needs it... replace with simply:
      #option = OPTION[option] if option.is_a?(Symbol)
      if option.is_a?(Symbol)        
        option, was = OPTION[option], option
        raise Err::CurlError.new("[BUG] Invalid CURLOPT " + was.inspect) if option.nil?
      end

      if option >= OPTION_OFF_T
        self.easy_setopt_curl_off_t(handle, option, value)
      elsif option >= OPTION_FUNCTIONPOINT
        self.easy_setopt_pointer(handle, option, value)
      elsif option >= OPTION_OBJECTPOINT
        if value.respond_to?(:to_str)
          self.easy_setopt_string(handle, option, value.to_str)
        else
          self.easy_setopt_pointer(handle, option, value)
        end
      elsif option >= OPTION_LONG
        self.easy_setopt_long(handle, option, value)
      end
    end
    
    # (Not documented)
    # 
    # @method easy_perform(curl)
    # @param [FFI::Pointer(*)] curl 
    # @return [Symbol from _enum_code_] 
    # @scope class
    attach_function :easy_perform, :curl_easy_perform, [:pointer], :code
    
    # (Not documented)
    # 
    # @method easy_cleanup(curl)
    # @param [FFI::Pointer(*)] curl 
    # @return [nil] 
    # @scope class
    attach_function :easy_cleanup, :curl_easy_cleanup, [:pointer], :void
    
    # NAME curl_easy_getinfo()
    # 
    # DESCRIPTION
    # 
    # Request internal information from the curl session with this function.  The
    # third argument MUST be a pointer to a long, a pointer to a char * or a
    # pointer to a double (as the documentation describes elsewhere).  The data
    # pointed to will be filled in accordingly and can be relied upon only if the
    # function returns CURLE_OK.  This function is intended to get used *AFTER* a
    # performed transfer, all results from this function are undefined until the
    # transfer is completed.
    # 
    # @method easy_getinfo(curl, info)
    # @param [FFI::Pointer(*)] curl 
    # @param [Symbol from _enum_info_] info 
    # @return [Symbol from _enum_code_] 
    # @scope class
    attach_function :easy_getinfo, :curl_easy_getinfo, [:pointer, :info, IntPtr], :code
    
    # NAME curl_easy_duphandle()
    # 
    # DESCRIPTION
    # 
    # Creates a new curl session handle with the same options set for the handle
    # passed in. Duplicating a handle could only be a matter of cloning data and
    # options, internal state info and things like persistent connections cannot
    # be transferred. It is useful in multithreaded applications when you can run
    # curl_easy_duphandle() for each new thread to avoid a series of identical
    # curl_easy_setopt() invokes in every thread.
    # 
    # @method easy_duphandle(curl)
    # @param [FFI::Pointer(*)] curl 
    # @return [FFI::Pointer(*)] 
    # @scope class
    attach_function :easy_duphandle, :curl_easy_duphandle, [:pointer], :pointer
    
    # NAME curl_easy_reset()
    # 
    # DESCRIPTION
    # 
    # Re-initializes a CURL handle to the default values. This puts back the
    # handle to the same state as it was in when it was just created.
    # 
    # It does keep: live connections, the Session ID cache, the DNS cache and the
    # cookies.
    # 
    # @method easy_reset(curl)
    # @param [FFI::Pointer(*)] curl 
    # @return [nil] 
    # @scope class
    attach_function :easy_reset, :curl_easy_reset, [:pointer], :void
    
    # NAME curl_easy_recv()
    # 
    # DESCRIPTION
    # 
    # Receives data from the connected socket. Use after successful
    # curl_easy_perform() with CURLOPT_CONNECT_ONLY option.
    # 
    # @method easy_recv(curl, buffer, buflen, n)
    # @param [FFI::Pointer(*)] curl 
    # @param [FFI::Pointer(*Void)] buffer 
    # @param [unknown] buflen 
    # @param [FFI::Pointer(*SizeT)] n 
    # @return [Symbol from _enum_code_] 
    # @scope class
    attach_function :easy_recv, :curl_easy_recv, [:pointer, :pointer, :char, :pointer], :code
    
    # NAME curl_easy_send()
    # 
    # DESCRIPTION
    # 
    # Sends data over the connected socket. Use after successful
    # curl_easy_perform() with CURLOPT_CONNECT_ONLY option.
    # 
    # @method easy_send(curl, buffer, buflen, n)
    # @param [FFI::Pointer(*)] curl 
    # @param [FFI::Pointer(*Void)] buffer 
    # @param [unknown] buflen 
    # @param [FFI::Pointer(*SizeT)] n 
    # @return [Symbol from _enum_code_] 
    # @scope class
    attach_function :easy_send, :curl_easy_send, [:pointer, :pointer, :char, :pointer], :code


    # THIS CODE COMES FROM https://github.com/typhoeus/ethon/blob/master/lib/ethon/curls/classes.rb
    # MIT LICENSE (see LICENSE.mit)
    enum(:msg_code, [:none, :done, :last])

    class Timeval < ::FFI::Struct
      if FFI::Platform.windows?
        layout :sec, :long,
              :usec, :long
      else
        layout :sec, :time_t,
              :usec, :suseconds_t
      end
    end

    class MsgData < ::FFI::Union
      layout :whatever, :pointer, :multi_code, :code
    end

    class Msg < ::FFI::Struct
      layout :code, :msg_code, :easy_handle, :pointer, :data, MsgData
    end

    class FDSet < ::FFI::Struct
      if FFI::Platform.windows?
        layout :fd_count, :uint,
               # TODO: Make it future proof by dynamically grabbing FD_SETSIZE.
               :fd_array, [:uint, 2048]

        def clear; self[:fd_count] = 0; end
      else
        # FD Set size.
        FD_SETSIZE = ::Curl::Libc.getdtablesize
        layout :fds_bits, [:long, FD_SETSIZE / ::FFI::Type::LONG.size]

        # :nodoc:
        def clear; super; end
      end
    end

    # THIS CODE COMES FROM https://github.com/arthurschreiber/curl-ffi/blob/master/lib/curl/curl.rb
    ## 
    MULTI_CODE = enum :multi_code, [
      :CALL_MULTI_PERFORM, -1,
      :OK,                  0,
      :BAD_HANDLE,          1,
      :BAD_EASY_HANDLE,     2,
      :OUT_OF_MEMORY,       3,
      :INTERNAL_ERROR,      4,
      :BAD_SOCKET,          5,
      :UNKNOWN_OPTION,      6
    ]

    attach_function :multi_add_handle, :curl_multi_add_handle, [:pointer, :pointer], :multi_code
    attach_function :multi_assign, :curl_multi_assign, [:pointer, :curl_socket_t, :pointer], :multi_code
    attach_function :multi_cleanup, :curl_multi_cleanup, [:pointer], :void
    attach_function :multi_fdset, :curl_multi_fdset, [:pointer, :pointer, :pointer, :pointer, :pointer], :multi_code
    attach_function :multi_info_read, :curl_multi_info_read, [:pointer, :pointer], Core::Msg.ptr
    attach_function :multi_init, :curl_multi_init, [], :pointer
    attach_function :multi_perform, :curl_multi_perform, [:pointer, :pointer], :multi_code
    attach_function :multi_remove_handle, :curl_multi_remove_handle, [:pointer, :pointer], :multi_code

    attach_function :multi_setopt_long, :curl_multi_setopt, [:pointer, :multi_option, :long], :multi_code
    attach_function :multi_setopt_string, :curl_multi_setopt, [:pointer, :multi_option, :string], :multi_code
    attach_function :multi_setopt_pointer, :curl_multi_setopt, [:pointer, :multi_option, :pointer], :multi_code
    attach_function :multi_setopt_curl_off_t, :curl_multi_setopt, [:pointer, :multi_option, :curl_off_t], :multi_code

    def self.multi_setopt(handle, option, value)
      option = MULTI_OPTION[option] if option.is_a?(Symbol)

      if option >= OPTION_OFF_T
        self.multi_setopt_curl_off_t(handle, option, value)
      elsif option >= OPTION_FUNCTIONPOINT
        self.multi_setopt_pointer(handle, option, value)
      elsif option >= OPTION_OBJECTPOINT
        if value.respond_to?(:to_str)
          self.multi_setopt_string(handle, option, value.to_str)
        else
          self.multi_setopt_pointer(handle, option, value)
        end
      elsif option >= OPTION_LONG
        self.multi_setopt_long(handle, option, value)
      end
    end

    attach_function :multi_socket_action, :curl_multi_socket_action, [:pointer, :curl_socket_t, :int, :pointer], :multi_code
    attach_function :multi_strerror, :curl_multi_strerror, [:multi_code], :string
    attach_function :multi_timeout, :curl_multi_timeout, [:pointer, :pointer], :multi_code

    if FFI::Platform.windows?
      ffi_lib 'ws2_32'
    else
      ffi_lib ::FFI::Library::LIBC
    end

    attach_function :select, [:int, Core::FDSet.ptr, Core::FDSet.ptr, Core::FDSet.ptr, Core::Timeval.ptr], :int    
    
  end
end
